module {
  sv.verbatim "`include \22fsm_enum_typedefs.sv\22"
  hw.type_scope @fsm_enum_typedecls {
    hw.typedecl @top_state_t : !hw.enum<A, B>
  } {output_file = #hw.output_file<"fsm_enum_typedefs.sv">}
  hw.module @top(in %in0 : i1, out out0 : i16, in %clk : !seq.clock, in %rst : i1) {
    %A = hw.enum.constant A : !hw.typealias<@fsm_enum_typedecls::@top_state_t, !hw.enum<A, B>>
    %to_A = sv.reg sym @A : !hw.inout<typealias<@fsm_enum_typedecls::@top_state_t, !hw.enum<A, B>>> 
    sv.assign %to_A, %A : !hw.typealias<@fsm_enum_typedecls::@top_state_t, !hw.enum<A, B>>
    %0 = sv.read_inout %to_A : !hw.inout<typealias<@fsm_enum_typedecls::@top_state_t, !hw.enum<A, B>>>
    %B = hw.enum.constant B : !hw.typealias<@fsm_enum_typedecls::@top_state_t, !hw.enum<A, B>>
    %to_B = sv.reg sym @B : !hw.inout<typealias<@fsm_enum_typedecls::@top_state_t, !hw.enum<A, B>>> 
    sv.assign %to_B, %B : !hw.typealias<@fsm_enum_typedecls::@top_state_t, !hw.enum<A, B>>
    %1 = sv.read_inout %to_B : !hw.inout<typealias<@fsm_enum_typedecls::@top_state_t, !hw.enum<A, B>>>
    %state_next = sv.reg : !hw.inout<typealias<@fsm_enum_typedecls::@top_state_t, !hw.enum<A, B>>> 
    %2 = sv.read_inout %state_next : !hw.inout<typealias<@fsm_enum_typedecls::@top_state_t, !hw.enum<A, B>>>
    %state_reg = seq.compreg sym @state_reg  %2, %clk reset %rst, %0 : !hw.typealias<@fsm_enum_typedecls::@top_state_t, !hw.enum<A, B>>  
    %cnt_next = sv.reg : !hw.inout<i16> 
    %c0_i16 = hw.constant 0 : i16
    %3 = sv.read_inout %cnt_next : !hw.inout<i16>
    %cnt_reg = seq.compreg sym @cnt_reg  %3, %clk reset %rst, %c0_i16 : i16  
    %cnt2_next = sv.reg : !hw.inout<i16> 
    %c0_i16_0 = hw.constant 0 : i16
    %4 = sv.read_inout %cnt2_next : !hw.inout<i16>
    %cnt2_reg = seq.compreg sym @cnt2_reg  %4, %clk reset %rst, %c0_i16_0 : i16  
    %c0_i16_1 = hw.constant 0 : i16
    %c1_i16 = hw.constant 1 : i16
    %c5_i16 = hw.constant 5 : i16
    %5 = comb.mux %in0, %1, %0 : !hw.typealias<@fsm_enum_typedecls::@top_state_t, !hw.enum<A, B>>
    %6 = comb.icmp eq %cnt_reg, %c5_i16 : i16
    %7 = comb.add %cnt_reg, %c1_i16 : i16
    %8 = comb.mux %6, %0, %1 : !hw.typealias<@fsm_enum_typedecls::@top_state_t, !hw.enum<A, B>>
    %output_0 = sv.reg : !hw.inout<i16> 
    sv.alwayscomb {
      sv.bpassign %cnt_next, %cnt_reg : i16
      sv.case %state_reg : !hw.typealias<@fsm_enum_typedecls::@top_state_t, !hw.enum<A, B>>
      case A: {
        sv.bpassign %state_next, %5 : !hw.typealias<@fsm_enum_typedecls::@top_state_t, !hw.enum<A, B>>
        sv.bpassign %output_0, %cnt_reg : i16
      }
      case B: {
        sv.bpassign %state_next, %8 : !hw.typealias<@fsm_enum_typedecls::@top_state_t, !hw.enum<A, B>>
        sv.case %2 : !hw.typealias<@fsm_enum_typedecls::@top_state_t, !hw.enum<A, B>>
        case A: {
          sv.bpassign %cnt_next, %c0_i16_1 : i16
        }
        case B: {
          sv.bpassign %cnt_next, %7 : i16
        }
        default: {
        }
        sv.bpassign %output_0, %cnt_reg : i16
      }
      default: {
      }
    }
    %9 = sv.read_inout %output_0 : !hw.inout<i16>
    hw.output %9 : i16
  }
}

